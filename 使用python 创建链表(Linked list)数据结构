#############  创建节点  start #################
# 下边的代码用于实现一个Node类：
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
此节点类只有一个构建函数，接收一个数据参数，其中next表示指针域的指针，实例化后得到一个节点对象(Node object)。具体例子如下：
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
node=Node(4)
print(node)
print(node.data)
print(node.next)
=> 	
	<__main__.Node object at 0x00000000043F6128>
	4
	None

#############  创建节点  end  #################


#############  创建链表类  ###############       
class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
  
    def is_empty(self):           # is_empty方法检查链表是否是一个空链表,这个方法只需要检查head节点是否指向None即可;
        return self.head is None  # 注意：这其实是一个判断语句，中间使用了“is”，返回值是布尔值；
  
    def append(self, data):       # append方法表示增加元素到链表，这和insert方法不同，前者使新增加的元素成为链表中第一个节点，
                                  # 而后者是根据索引值来判断插入到链表的哪个位置
        node = Node(data)	  #先将输入数据节点化，既然要新增加节点，首先把Node类实例化得到一个node对象(先将输入数据节点化再谈别的)
				  #这里有两种情况需要考虑，一是链表是一个空链表时怎样append一个节点；二是当链表不是空链表时又怎样append
				  #一个节点？
        if self.head is None:	  #为True时，把链表的head和tail都指向了node
            self.head = node
            self.tail = node
        else:			  #为False时说明此时的链表已经不是空的了，再增加一个节点时head已经指向了第一个节点，所以不为None
				  #链表不为空，下面也就没有head的事了。增加第二个节点的操作需要分两步完成：
            self.tail.next = node # 第一步：把上一个节点的next指针指向当前node
            self.tail = node	  # 第二步：把tail移动到当前node
  
    def iter(self):
        if not self.head:	  #当是遍历一个空链表时，self.head为none，所以not none就是True，即为空则返回None，可省略；
            return
        cur = self.head		  #如果不是空链表就让一个局部变量cur指向head,
        yield cur.data		  #并把head的data属性yield出来；
        while cur.next:
            cur = cur.next
            yield cur.data
  
    def insert(self, idx, value):
        cur = self.head
        cur_idx = 0
        if cur is None:             # 判断是否是空链表
            raise Exception('The list is an empty list')
        while cur_idx < idx-1:   # 遍历链表
            cur = cur.next
            if cur is None:   # 判断是不是最后一个元素
                raise Exception('list length less than index')
            cur_idx += 1
        node = Node(value)
        node.next = cur.next
        cur.next = node
        if node.next is None:
            self.tail = node
  
    def remove(self, idx):
        cur = self.head
        cur_idx = 0
        if self.head is None:  # 空链表时
            raise Exception('The list is an empty list')
        while cur_idx < idx-1:
            cur = cur.next
            if cur is None:
                raise Exception('list length less than index')
            cur_idx += 1
        if idx == 0:   # 当删除第一个节点时
            self.head = cur.next
            cur = cur.next
            return
        if self.head is self.tail:   # 当只有一个节点的链表时
            self.head = None
            self.tail = None
            return
        cur.next = cur.next.next
        if cur.next is None:  # 当删除的节点是链表最后一个节点时
            self.tail = cur
  
    def size(self):
        current = self.head
        count = 0
        if current is None:
            return 'The list is an empty list'
        while current is not None:
            count += 1
            current = current.next
        return count
  
    def search(self, item):
        current = self.head
        found = False
        while current is not None and not found:
            if current.data == item:
                found = True
            else:
                current = current.next
        return found
  
if __name__ == '__main__':
    link_list = LinkedList()
    for i in range(150):
        link_list.append(i)
#    print(link_list.is_empty())
#    link_list.insert(10, 30)
  
#    link_list.remove(0)
  
    for node in link_list.iter():
        print('node is {0}'.format(node))
    print(link_list.size())
#    print(link_list.search(20))
