Given a 32-bit signed integer, reverse digits of an integer.

Example 1:

    Input: 123
    Output:  321
    Example 2:

    Input: -123
    Output: -321
    Example 3:

    Input: 120
    Output: 21
Note:
Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range.
For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.

我的解决方案代码如下：
class Solution:
    def reverse(self, x):
        """
        :type x: int
        :rtype: int
        """
        if (x<-2147483647)|(x>2147483648):  
            return 0   
        elif x==0:  
            return 0  
        else:  
            if x>0:  
                flag=True  
            else:  
                flag=False   
                x*=-1  
            x_list=list(str(x))  
            while x_list[-1]=='0':  
                x_list.pop()  
            tmp=''.join(x_list[::-1])  
            if flag:  
                m= int(tmp)   
            else:  
                m= int('-'+tmp)
            if (m<-2147483647)|(m>2147483648): # 判断是否超出32位寄存器所能表示的范围，溢出则fanhui
                return 0
            else:
                return m
  大牛的解决方案代码：
  Get the sign, get the reversed absolute integer, and return their product if r didn't "overflow".

def reverse(self, x):
    s = cmp(x, 0)  # 通过与0进行比较获得输入数据的符号，然后将符号存起来，以便后面再添加上；
    r = int("s*x"[::-1]) # "s*x"有两个目的，s*x目的是将x转化成无符号数，因为无论x是正还是负，与自己的符号相乘都会变成正数
                         # 这样才方便将其强制转化成str类型，而变成了字符串就可以用[::-1]功能实现内容翻转了这就是第二个功能；
    return s*r * (r < 2**31)  # s*r：因为r是unsigned int型，所以要把符号还给人家，这样就用到了上面s所存储的符号，通过
                              # 相乘即可实现；r < 2**31：是判断是否溢出，通过乘上这个条件来控制结果是0还是输出原值，条件为真
                              # 不影响输出，条件为假直接输出0，真实太聪明的做法了；
As compressed one-liner, for potential comparison:

def reverse(self, x):
    s=cmp(x,0);r=int(`s*x`[::-1]);return(r<2**31)*s*r
  学到的知识：
  一、32位机int取值范围是-2^31~2^31-1;判断是否溢出可用(r<2**（寄存器位数-1）)
  二、列表、元组、字符串均可翻转输出，用[::-1]即可实现翻转，如果想翻转int，则可将其先换成str翻转之后再转换回int型；
  三、使用cmp(x,0)可以获取x的符号，其实0还可以换成其他数值，将其作为一个比较的对象，相等返回0，大于返回1，小于这个值
      返回-1；
  四、感想：不同数据类型相互切换可以取得意想不到的效果，你做不到的我可以做到，优势互补；在转换之前只需把你用的信息存储下来，
      等实现了还要恢复它原来的样子，这样就用到了刚才存储的关键信息了，leetcode（1）也用到这种思想，借助字典的value存储了
      不同元素的下标，以便后续的使用。所以“曲线救国”策略在编程中真的很好用。
